[
    {
        "title": "## 객체 리스트 정렬 (난이도 중상)",
        "text": " ## 객체 리스트 정렬 (난이도 중상) \n ### 문제 설명\n주어진 리스트에는 여러 개의 사전 형식 객체가 포함되어 있으며, 각 객체는 `name`과 `age` 필드를 포함합니다. **`Merge Sort` 알고리즘**을 사용하여 `age` 기준으로 오름차순으로 정렬된 결과를 반환하는 프로그램을 작성하세요.\n### 입력\n  Python 리스트 형식의 객체들\n  ```\n  target_list = [\n      {\"name\": \"Sean\", \"age\": 23},\n      {\"name\": \"John\", \"age\": 19},\n      {\"name\": \"Amy\", \"age\": 22},\n      {\"name\": \"Elly\", \"age\": 27},\n      {\"name\": \"Bob\", \"age\": 15},\n      {\"name\": \"Alice\", \"age\": 23},\n      {\"name\": \"Clara\", \"age\": 18},\n      {\"name\": \"David\", \"age\": 21},\n      {\"name\": \"Eve\", \"age\": 20},\n      {\"name\": \"Daniel\", \"age\": 30}\n  ]\n  ```\n  \n  ### 출력 \n  `age` 기준으로 정렬된 새로운 리스트\n  ```\n  [\n      {\"name\": \"Bob\", \"age\": 15},\n      {\"name\": \"Clara\", \"age\": 18},\n      {\"name\": \"John\", \"age\": 19},\n      {\"name\": \"Eve\", \"age\": 20},\n      {\"name\": \"David\", \"age\": 21},\n      {\"name\": \"Amy\", \"age\": 22},\n      {\"name\": \"Alice\", \"age\": 23},\n      {\"name\": \"Sean\", \"age\": 23},\n      {\"name\": \"Elly\", \"age\": 27},\n      {\"name\": \"Daniel\", \"age\": 30}\n  ]\n  ```\n  \n  ### 제약 사항 \n  1. **Merge Sort 알고리즘을 구현**하여 정렬하세요. Python의 내장 정렬 함수(`sorted`, `.sort()`) 사용은 금지됩니다.\n  2. **입력 리스트는 수정하지 말고**, 정렬된 새 리스트를 반환해야 합니다.\n  3. 알고리즘은 **재귀적**으로 작성하세요.\n  4. 만약 `age`가 같다면, **`name` 기준으로 오름차순**(알파벳 순서)으로 정렬하세요.\n  5. `merge_sort`라는 함수를 구현해야 하며, 다음 형식으로 작성되어야 합니다:\n  ```\n  def merge_sort(target_list):\n      # TODO\n  ```\n"
    },
    {
        "title": "## 최소 경로 찾기 (난이도 상)",
        "text": " ## 최소 경로 찾기 (난이도 상)\n  ### 문제 설명\n  도시 간 연결과 이동 비용이 주어집니다. 특정 출발 도시에서 다른 모든 도시로 가는 최소 이동 비용을 계산하세요.\n  입력은 도시 수와 연결 정보를 포함하며, **`다익스트라` 알고리즘**을 사용하여 문제를 해결하세요.\n  \n  ### 입력\n  - 도시의 개수 `n` (1 ≤ n ≤ 100)\n  - 연결 정보 리스트 `connections`, 각 요소는 `[city1, city2, cost]` 형식으로 두 도시 간 이동 비용을 나타냅니다.\n  - 출발 도시 번호 `start` (1 ≤ start ≤ n)\n  ```\n  n = 5\n  connections = [\n      [1, 2, 2],\n      [1, 3, 4],\n      [2, 3, 1],\n      [2, 4, 7],\n      [3, 5, 3]\n  ]\n  start = 1\n  ```\n  \n  ### 출력\n  출발 도시에서 각 도시로의 최소 이동 비용 리스트. 만약 특정 도시로 이동할 수 없다면 `inf`를 표시하세요.\n  ```\n  [0, 2, 3, 9, 6]  # (도시 1에서 도시 2로 2, 도시 3으로 3, … 도시 4로 9, 도시 5로 6)\n  ```"
    },
    {
        "title": "## 리스트 내 두 숫자의 합 (난이도 중하)",
        "text": " ## 리스트 내 두 숫자의 합 (난이도 중하)\n  ### 문제 설명\n  정수 리스트와 목표 값 `target`이 주어집니다. 리스트에서 두 숫자를 골라 그 합이 `target`이 되는 경우, 두 숫자의 인덱스를 `tuple`로 반환하세요. (한 쌍만 찾으면 됩니다.)\n  \n  ### 입력\n  1. 정수 리스트 `nums`\n  2. 목표 정수 `target`\n  ```\n  nums = [2, 7, 11, 15, 1, 8]\n  target = 9\n  ```\n  \n  ### 출력\n  합이 `target`이 되는 두 숫자의 인덱스\n  ```\n  (0, 1)  # (nums[0] + nums[1] = 9)\n  ```"
    },
    {
        "title": "## 문자열 압축 (난이도 하)",
        "text": " ## 문자열 압축 (난이도 하)\n  ### 문제 설명\n  문자열이 주어졌을 때, 연속으로 반복되는 문자를 압축하여 반환하세요. 압축된 형식은 `[문자][횟수]`입니다. 단, 횟수가 1인 경우는 생략합니다.\n  \n  ### 입력\n  문자열 `s`\n  ```\n  s = \"aaabbcddddd\"\n  ```\n  \n  ### 출력\n  압축된 문자열\n  ```\n  \"a3b2cd5\"\n  ```\n    "
    },
    {
        "title": "## 최대 구간 합 (난이도 중)",
        "text": " ## 최대 구간 합 (난이도 중)\n  ### 문제 설명\n  정수로 이루어진 배열이 주어집니다. 배열에서 연속된 숫자의 합 중 최댓값을 반환하세요. 배열에는 음수도 포함될 수 있습니다.\n  \n  ### 입력\n  정수 리스트 `nums`\n  ```\n  nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n  ```\n  \n  ### 출력\n  최대 연속 부분 합\n  ```\n  6  # (부분 배열 [4, -1, 2, 1]의 합)\n  ```\n  \n  ### 문제 풀이 힌트\n  1. 부분 배열을 구하기 위해 배열을 처음부터 끝까지 순회하며 합계를 갱신하세요.\n  2. 음수로 인해 합계가 줄어들면, 새로운 구간을 시작하세요.\n  3. 시간 복잡도는 `O(n)`으로 해결할 수 있습니다.\n  4. 이 문제는 `카데인 알고리즘(Kadane's Algorithm)`를 적용하면 효과적으로 해결할 수 있습니다. 쉬운 접근법으로는 `가능한 모든 부분 배열을 계산`하는 것도 가능합니다.\n"
    },
    {
        "title": "## 웹 크롤링 (난이도 상)",
        "text": " ## 웹 크롤링 (난이도 상)\n  ### 문제 설명\n  멜론 TOP 100 차트 [`https://www.melon.com/chart/`](https://www.melon.com/chart/) 에 올라간 곡들의 장르를 selenium을 활용해 크롤링하여, 차트에 각 장르가 몇 차례 출현했는지를 세고 딕셔너리 형태로 반환하세요.\n  장르 정보는 각 곡의 (앨범 커버 옆) “곡 정보” 버튼을 클릭해 곡 정보 페이지로 이동한 이후에 얻을 수 있습니다.\n  별도의 입력값은 없습니다.\n  \n  ### 스켈레톤 코드\n  ```\n  from selenium import webdriver\n  from selenium.webdriver.common.by import By\n  import time\n  \n  def web_driver():\n    options = webdriver.ChromeOptions()\n    options.add_argument('--headless') \n    options.add_argument('--no-sandbox')\n    options.add_argument('--disable-dev-shm-usage') \n    options.add_argument('lang=ko_KR') \n    driver = webdriver.Chrome(options=options)\n    return driver\n   \n  driver = web_driver()\n  \n  ## Fill here\n  \n  driver.quit()\n  ```\n  \n  ### 출력\n  각 장르의 출현 횟수를 저장한 딕셔너리 (예시는 상위 50개만 뽑은 것 - 완전히 같지 않을 수 있음)\n  ```\n  {'발라드': 14, '랩/힙합': 3, '댄스': 18, '록/메탈': 6, 'R&B/Soul': 3, '포크/블루스': 1, 'J-POP': 1, '국내드라마': 4, '인디음악': 2, '성인가요/트로트': 1, 'POP': 2, '재즈': 1, '애시드/퓨전/팝': 1}\n  ```\n  \n  ### 제약 사항 및 문제 풀이 힌트\n  1. 스켈레톤에 제시된 것 이외에 selenium의 다른 메소드는 활용하지 마세요.\n  2. 버튼을  클릭하여 페이지를 이동할 때는 `{driver_element}.click()` , 다시 차트 페이지로 돌아올 때는  `driver.back()` 메소드를 활용하세요. \n  3. 1위부터 50위까지의 곡들과 50위부터 100위까지의 곡들은 서로 다른 태그에 정보가 들어 있습니다. 두 가지 경우를 모두 포함시킬 수 있도록 해주세요."
    }
]
